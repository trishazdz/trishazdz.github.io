<!doctype html>
<html>
<head>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
	<script src="http://d3js.org/d3.v3.min.js"  charset="utf-8"></script>
	<script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/knockout/3.3.0/knockout-min.js'></script>

	<link rel="stylesheet" href="ellie.css">

</head>
<body style="margin-left:10px">
	

	<div id="dv-container">

		<form data-bind="submit: fetchSession">
			<input id="sessionIdInput" type="number" data-bind="textInput: sessionId" placeholder="Participant ID" />
			<button class="btn btn-default" data-bind="css: {disabled: !sessionId()}" type="submit">Find Data</button>
		</form>
		<p class="warning">
			<span data-bind="text: errorId"></span><span data-bind="text: error"></span>
		</p>

		<div data-bind="if: session">
			<p id="activeSession">Showing Participant ID: <span data-bind="text: activeSessionId"></span></p>
		</div>

		<div id="canvas-container"></div>

		<div class="row">
			<div id="slider" data-bind="if: chain">
				<div class="col-sm-2">
					<button id="chain-play" class="btn btn-default" data-bind="click: chainToggle">
						<span data-bind="if: !chainPlaying()">Play Chain</span>
						<span data-bind="if: chainPlaying()">Stop</span>
					</button>
				</div>


				<div class="col-sm-9" id="slide">
					<div>
						<input type="range" step="1"
							data-bind="value: slideInput, valueUpdate: 'input', attr: {min: 1, max: chain().sessions.length}"
							/>
					</div>
				</div>

			</div>
		</div>
	</div>

	<script>
		var data, stimuli;

		var w = 500, h = 500, xPadding = 20, yPadding = 30;
		
		var toolTip = d3.select('body').append("div")
		        	.attr("class", "tooltip")
		        	.style("opacity", 0);

		function setDimensions() {

		};

		function Viewmodel() {
			var self = this;
			this.chainPlaying = ko.observable(false); //is the chain playing?

			this.sessionId = ko.observable(); // session id input
			this.activeSessionId = ko.observable();

			this.chain = ko.observable();
			this.slideInput = ko.observable();

			this.session = ko.computed(function() {
				if (self.activeSessionId() && self.chain()) {
					return self.chain().getSessionById(self.activeSessionId());
				} else {
					return undefined;
				}
			});

			this.chainSessionIndex = ko.computed(function() {
				if (self.slideInput() && self.session()) {
					return self.slideInput() - 1;
				}
			});

			this.chainSessionIndex.subscribe(function(index) {
				self.slideChange(index);
			});

			this.error = ko.observable(undefined);
			this.errorId = ko.observable(undefined);

			this.canvas = undefined;

			this.hideErrorBars = ko.observable(false);
			this.hideSource = ko.observable(false);

			this.transitionSpeed = 800;

			this.initSvg = function() {
				this.canvas = d3.select("div#canvas-container")
		        	.append("svg")
		        	.attr("id", "dv")
		        	.attr("width", w)
		        	.attr("height", h);

		        var xScale = d3.scale.linear()
					.domain([0, 1000])
					.range([0, w]);

				var xAxis = d3.svg.axis()
					.scale(xScale)
					.orient("top")
					.ticks(4);

				this.canvas.append("g")
			        	.attr("class", "axis")
			        	.attr("id", "x-axis")
			        	.attr("transform", "translate(0, 45)")
			        	.call(xAxis);

			    this.canvas.append("text")
			    	.attr("class", "axis-label")
			    	.attr("text-anchor", "middle")
			    	.attr("x", w / 2)
			    	.attr("y", yPadding / 2)
			    	.text("Time Between Taps (ms)");		    
	
			    this.fetchSession(1306);
			};

			this.fetchSession = function(inputId) {
				var id = typeof inputId === 'number' ? inputId : this.sessionId();

				if (data[id]) {
					this.sessionId('');
					this.error("");
					this.errorId("");

					this.slideInput(''); // clear previous slideInput
					this.activeSessionId(id);
					this.initChain(data[id].ChainID);

					this.plotSession();

				} else {
					if (!this.sessionId()) {
						this.errorId("");
						this.error("Please type in a valid Participant ID");
					} else {
						this.errorId(id);
						this.error(" doesn't exist. Please double check that you have entered the correct ID.");
					}
				}

			};

			this.initChain = function(chainId) {
				var chain = new Chain(this.getChain(chainId));
				chain.sortSessions();
				this.chain(chain);

				if ( !this.chain().getSessionById(this.activeSessionId()) ) {
					// if the chain doesn't retrieve the session it means that it was rejected
					// just show the first generation of the chain and display error message

					this.errorId(this.activeSessionId());
					this.error(" You're an outlier. We couldn't use you in this chain, but here is the data for the chain you would have been in.");

					var id = this.chain().getSessionByIndex(0).ID;
					this.activeSessionId(id);
					this.slideInput(1);
				} else {
					var index = this.chain().getSessionIndexById(this.activeSessionId());
					this.slideInput(index + 1);
				}
				
			};

			this.getChain = function(chainId) {
				var chain = [];
				for (var key in data) {
					if (data[key].ChainID == chainId) {
						var element = data[key];
						element.ID = key;
						chain.push(new Session(element));
					}
				};

				return chain;
			};

			this.getDataElementById = function(id) {
				if (id >= 1000) {
					var element = data[id];

					if (element) { 
						element.ID = id;
						return element; 
					} 
					else { return false; }
				} else {
					// fetch seed stimuli

					this.getStimuli()
				}
				
			};

			this.getStimuli = function(seed, type) {
				var key = seed + type;

				var values = {
					"0t": stimuli["1"],
					"1t": stimuli["2"],
					"2t": stimuli["3"],
					"3t": stimuli["4"],
					"0m": stimuli["5"],
					"1m": stimuli["6"],
					"2m": stimuli["7"],
					"3m": stimuli["8"]
				};

				return values[key];
			};

			this.slideChange = function(index) {
				if (index != undefined) {
					var session = this.chain().getSessionByIndex(this.chainSessionIndex());
					this.activeSessionId(session.ID);
					this.plotSession();
				}	
			};

			this.plotSession = function() {
				var session = this.session();
				var sessionStimuli = this.getStimuli(session.Seed, session.Type);

				if (session.SourceID >= 1000) {
					var sessionSource = new Session( this.getDataElementById(session.SourceID) );
				} else {
					var sessionSource = {Tapping: sessionStimuli.SeedStimuli};
				}

				var domainMin = 0; //= d3.min(sessionStimuli.SeedStimuli, function(d) { return d; }) - 750;
				var domainMax = 500 + d3.max(sessionStimuli.SeedStimuli, function(d) {return d;});

				var xScale = d3.scale.linear()
		        	.domain([domainMin, domainMax])
		        	.range([xPadding, w - xPadding]);

		        var yScale = d3.scale.linear()
		    		.domain([0, sessionStimuli.SeedStimuli.length])
		    		.range([yPadding * 2, h]);

		        var bothData = [];

		        for ( var i = 0; i < sessionSource.Tapping.length; i++ ) {
		        	bothData.push( {source: sessionSource.Tapping[i], 
		        					session: session.Tapping[i] } );
		        };


		        var errorMargins = this.canvas.selectAll(".error-margin")
		        	.data(bothData);

		        errorMargins
		        	.transition()
		        	.duration(self.transitionSpeed)
		        		.attr("class", function(d) {
		        			if (d.session && d.source) {			
			        			if (self.hideErrorBars()) {
			        				if (d.session > d.source) {
			        					return "error-margin";
				        			} else {
				        				return "error-margin";
				        			}
			        			} else {
			        				if (d.session > d.source) {
				        				return "error-margin slower";
				        			} else {
				        				return "error-margin faster";
				        			}
			        			}
			        		};
		        		})
		        		.attr("x1", function(d) {
		        			if (d.session) {
			        			return xScale(d.session);		        				
		        			}
		        		})
		        		.attr("y1", function(d, i) {
		        			return yScale(i);
		        		})
		        		.attr("x2", function(d) {
		        			return xScale(d.source);
		        		})
		        		.attr("y2", function(d, i) {
		        			return yScale(i);
		        		});
		        errorMargins
		        	.enter()
		        		.append("line")
		        		.attr("class", function(d) {
		        			if (d.session && d.source) {
			        			if (self.hideErrorBars()) {
			        				if (d.session > d.source) {
				        				return "error-margin";
				        			} else {
				        				return "error-margin";
				        			}
			        			} else {		        			
				        			if (d.session > d.source) {
				        				return "error-margin slower";
				        			} else {
				        				return "error-margin faster";
				        			}
				        		}
				        	}
		        		})
		        		.attr("x1", function(d) {
		        			if (d.session) {
			        			return xScale(d.session);
		        			}
		        		})
		        		.attr("y1", function(d, i) {
		        			return yScale(i);
		        		})
		        		.attr("x2", function(d) {
		        			return xScale(d.source);
		        		})
		        		.attr("y2", function(d, i) {
		        			return yScale(i);
		        		});

		        errorMargins
		        	.exit()
		        		.remove(); 

		       	var sourcePoints = this.canvas.selectAll(".source-point")
		        	.data(bothData);

		        sourcePoints
		        	.transition()
		        	.duration(self.transitionSpeed)
		        		.attr("r", function(d) {
		        			if (d.session && d.source) {
		        				return 7;		
		        			}
		        		})
		       			.attr("cx", function(d) {
		       				if (d.source && d.session) {
		       					return xScale(d.source);
		       				}
		        		})
		        		.attr("cy", function(d, i) {
		        			if (d.source && d.session) {		        			
		        				return yScale(i);
		        			}
		        		})
		        		.attr("class", function(d) {
		        			if (d.session && d.source) {
			        			if (self.hideSource()) {
			        				if (d.session > d.source ) {
				        				return "source-point";
				        			} else {
				        				return "source-point";
				        			}
			        			} else {
			        				if (d.session > d.source ) {
				        				return "source-point slower";
				        			} else {
				        				return "source-point faster";
				        			}
			        			}
			        		}
		        		});

		        sourcePoints
		        	.enter()
		        		.append("circle")
		        		.attr("r", function(d) {
		        			if (d.session && d.source) {
		        				return 7;		
		        			}
		        		})
		        		.attr("cx", function(d) {
		        			if (d.session && d.source) {
		        				return xScale(d.source);
		        			}
		        		})
		        		.attr("cy", function(d, i) {
		        			if (d.session && d.source) {
		        				return yScale(i);
		        			}
		        		})
		        		.attr("class", function(d, i) {
		        			if (d.session && d.source) {
		        				if (self.hideSource()) {
				        			if (d.session > d.source ) {
				        				return "source-point";
				        			} else {
				        				return "source-point";
				        			}
				        		} else {
				        			if (d.session > d.source) {
				        				return "source-point slower";
				        			} else {
				        				return "source-point faster";
				        			}
				        		}
			        		}
		        		});

		        sourcePoints
		        	.exit()
		        		.remove();

		        
		        var seedLine = this.canvas.selectAll("line.seed-line")
		        	.data(sessionStimuli.SeedStimuli);

		        seedLine
		        	.transition()
		        	.duration(self.transitionSpeed * 1.5)
			        	.attr("x1", function(d) {
			        		return xScale(d);
			        	})
			        	.attr("y1", function(d, i) {
			        		return (yScale(i) - 6);
			        	})
			        	.attr("x2", function(d) {
			        		return xScale(d);
			        	})
			        	.attr("y2", function(d, i) {
			        		return (yScale(i) + 6);
			        	});
			    seedLine
			    		.on("mouseover", function(d) {
			        		toolTip.transition()
			        			.duration(100)
			        			.style("opacity", .9);
			        		toolTip.text("asdfasdfasd")
			        			.style("left", (d3.event.pageX) + "px")
			        			.style("top", (d3.event.pageY - 50) + "px");
			        	})
			        	.on("mouseout", function(d) {
			        		toolTip.transition()
			        			.delay(500 )
			        			.duration(500)
			        			.style("opacity", 0);
			        	});

			    seedLine
		        	.enter()
			        	.append("line")
			        	.attr("x1", function(d) {
			        		return xScale(d);
			        	})
			        	.attr("y1", function(d, i) {
			        		return (yScale(i) - 6);
			        	})
			        	.attr("x2", function(d) {
			        		return xScale(d);
			        	})
			        	.attr("y2", function(d, i) {
			        		return (yScale(i) + 6);
			        	})
			        	.attr("class", "seed-line")
			        	.on("mouseover", function(d) {
			        		toolTip.transition()
			        			.duration(200)
			        			.style("opacity", .9);
			        		toolTip.text("asdfasdfasd")
			        			.style("left", (d3.event.pageX) + "px")
			        			.style("top", (d3.event.pageY - 50) + "px");
			        	})
			        	.on("mouseout", function(d) {
			        		toolTip.transition()
			        			.duration(500)
			        			.style("opacity", 0);
			        	});

			    seedLine
		        	.exit()
		        		.remove();

		        /*

			    var seedLabel = this.canvas.select(".seed-label")
			    	.data(sessionStimuli.SeedStimuli);

			    seedLabel
			    		.attr("transform", function(d) {
			    			return "rotate(-90 " + (xScale(d) + 12) + "," + (h - yPadding * 1.2) + ")";
			    		})
			    		.attr("y", h - yPadding * 1.2 )
			    	.transition()
			    	.duration(self.transitionSpeed * 1.5)
			   			.attr("x", function(d) {
			   				return xScale(d) + 12;
			   			})
			   			.attr("text-anchor", "beginning")
			    		.text("Original Source");
			    seedLabel
			   		.enter()
			   			this.canvas.append("text")
			   			.attr("class", "seed-label"); 

			    seedLabel
			    	.exit()
			    		.remove();
			   	*/
				
				var dataPoints = this.canvas.selectAll(".data-point")
					.data(session.Tapping);

				dataPoints
					.transition()
					.duration(self.transitionSpeed)
			        	.attr("cx", function(d) {
			        		return xScale(d);
			       		})
			        	.attr("cy", function(d, i) {
			        		return yScale(i);
			        	})
			        	.attr("class", "data-point");

			    dataPoints
					.enter()
		        		.append("circle")
		        		.attr("r", function(d) {
		        			return 7;
		        		})
		        		.attr("cx", function(d) {
			        		return xScale(d);
			       		})
			        	.attr("cy", function(d, i) {
			        		return yScale(i);
			        	})
			        	.attr("class", "data-point");

		        dataPoints
		        	.exit()
		        		.remove();

		        var xAxis = d3.svg.axis()
					.scale(xScale)
					.orient("top")
					.ticks(5);
					
		        this.canvas.select("#x-axis")
		        	.call(xAxis);

		        
		        var activeGeneration = this.canvas.selectAll(".activeGeneration")
		        	.data([0]);

		        activeGeneration
		        		.attr("x", w - xPadding )
			    		.attr("y", h - yPadding)
			    		.text(self.slideInput())
		    		.enter()
		    			.append("text")
		    			.attr("text-anchor", "end")
			    		.attr("class", "activeGeneration");
			    		

			};

			this.chainToggle = function() {
				// chain is not playing
				if (!self.chainPlaying()) {
					self.chainPlaying(true);
					self.hideErrorBars(true);
					self.hideSource(true);

					self.slideInput(1);
					chainPlay = setInterval(function() {
						if (self.slideInput() < self.chain().sessions.length) {
							self.slideInput(Number(self.slideInput()) + 1);
						} else {
							clearInterval(chainPlay);
							self.chainPlaying(false);

							self.hideErrorBars(false);
							self.hideSource(false);
							self.plotSession();
						}
					}, 900);
				} else { //chain is playing so cancel it
					self.chainPlaying(false);
					clearInterval(chainPlay);

					self.hideErrorBars(false);
					self.hideSource(false);

					self.plotSession();
				}
				
			};
		};
		

		function Session(params) {
			for (key in params) {
				this[key] = params[key];
			}
		}

		Session.prototype.getAverage = function() {
			var sum = 0;

			for (var i = 0; i < this.taps.length; i++) {
				sum += Number(this.taps[i]);
			}

			return sum / this.taps.length;
		}

		function Chain(array) {
			this.sessions = array;
			this.rejects = [];
		}

		Chain.prototype.getSessionById = function(id) {
			var session;

			this.sessions.map(function(element) {
				if (Number(element.ID) == Number(id)) {
					session = element;
				}
			});

			return session;
		}

		Chain.prototype.getSessionIndexById = function(id) {
			var index;

			this.sessions.map(function(element, i) {
				if (Number(element.ID) == Number(id)) {
					index = i;
				}
			});

			return index;
		}

		Chain.prototype.getSessionByIndex = function(index) {
			var session = this.sessions[index];
			return session;
		}

		Chain.prototype.sortSessions = function() {
			var reject = [];
			var keep = [];

			this.sessions.map(function(element, index) {
				if (element.Chain[0] === 'r') {
					reject.push(element);
				} else {
					keep.push(element);
				}
			}, this);

			this.sessions = keep;
			this.rejects = reject;

			function compare(a,b) {
				if (Number(a.Chain) < Number(b.Chain)) {
					return -1;
				}
				if (Number(a.Chain) > Number(b.Chain)) {
					return 1;
				}
				return 0
			}

			this.sessions.sort(compare);
		}

		Chain.prototype.getTappingMaxValue = function() {
			var sessions = this.sessions;
			var values = [];

			for (var i = 0; i < sessions.length; i++ ) {
				sessions[i]['Tapping'].map(function(element) {
					values.push(Number(element));
				});
			}

			var max = Math.max.apply(Math, values);
			return max;
		}

		Chain.prototype.getTappingMinValue = function() {
			var sessions = this.sessions;
			var values = [];

			for (var i = 0; i < sessions.length; i++ ) {
				sessions[i]['Tapping'].map(function(element) {
					values.push(Number(element));
				});
			}

			var min = Math.min.apply(Math, values);
			return min;
		}

	    
		d3.json('updated.json', function(json) {
			data = json;

			d3.json('stimuli.json', function(json) {
				stimuli = json;

				var vm = new Viewmodel();
				ko.applyBindings(vm);
				vm.initSvg();
			});
		});
	</script>
</body>
</html>